package Day2;

public class BigONotation_10 {
    /**
     * Память под примитивные аррайлисты или массивы выделяется так. 4 байта на 1 элемент и они все стоят рядом. Если нужно
     * найти какойто элемент то берется начальня точка в памяти, где начинаются обьекты и берется индекс под которым стоит элемент
     * и вычисляется оп формуле.
     * Начальная точка в памяти + индекс обьекта умножить на 4 байта (Нарпиклад 120+3 умножить на 4 = 132) - это значит что
     * обьект под индексом 3 находится в памяти на 132 позиции.
     *
     * На ссылочные типы даннаъ память выделяется и под ссылку и под обьект. Под ссылку память выделяется так что, на каждый
     * обьект выделяется по 8 байтов и они тоже стоят в порядку очереди, но в этих 8 байтах находится сыылка на сам обьект кторый
     * находится в другом каком-то месте. Чтобы найти какойто элемент то берется начальня точка в памяти, где начинаются
     * обьекты и берется индекс под которым стоит элемент и вычисляется оп формуле.
     * Начальная точка памяти + индекс обьекта умножить на 8 и на этой позиции булет находится ссылка на сам файл.
     *
     * Наприкалд - 200+6 умножить на 8 = 248(и на позиции 248 находится ссылка наприклад 569, и на позиции 569 будет обьект)
     *
     *
     * BigONotation - выражает в себе скорость выполнения алгротима(  O(1) - всегда одинаковая скорость
     *                                                                O(n) - всегда разная скорость ( зависит от к-лва элементов )
     *                                                                O(logn) - не одинаковая но лучше как O(n)
     *  Иерархия: 1. O(1)  2. O(logn)  3. O(n)
     *
     * Поэтоу при нахождении чего-то в аррайлисте или массиве скорость равняется O(1) потому что ее всегда легко найти
     * Но при на добавлении или удалении иои сложении всех элементов на какой-то позиции скоросто будет O(n),
     * но если добавлять на свобоное место то будет O(1).
     *
     * В линкед листе ситуация просиход по жругому и казалось бы лучше но нет, если есть миллион элементов и нужно
     * добавлять в середу 100000 то каждый раз будет происходить переход по всему циклу додавание 1 элемента,
     * потом снова переъод по всем элементам и доьавление еще 1 и так 10000 раз и это будет O(n)
     *Но если добавлять в начало или конец то это будет O(1) так как просто будут добавляться элементы и создание новых цепочек
     *
     */
}
